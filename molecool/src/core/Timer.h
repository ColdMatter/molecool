#pragma once

/*
This is a scoped timer that measures the time between instantiation 
and when the timer object goes out of scope (or is stopped).  

Usage is generally as follows.  One option is to instantiate the 
timer in a function that is to be timed:
void someFunction() 
{                           // begin function scope
    Timer timer("name");    // instantiate timer, timing starts
    ***CODE TO TIME***      // function actions to be timed
}                           // timer destroyed when leaving function scope, timing stops

Alternatively, you can always create a local scope with {}:
{                               // start local scope
    Timer timer("aName"); // instantiate timer, timing starts 
    ***CODE TO TIME***          // scoped actions to be timed
}                               // timer destroyed when leaving local scope, timing stops
*/

#include <chrono>
#include <boost/accumulators/accumulators.hpp>
#include <boost/accumulators/statistics/stats.hpp>
#include <boost/accumulators/statistics/mean.hpp>
#include <boost/accumulators/statistics/min.hpp>
#include <boost/accumulators/statistics/max.hpp>
#include <boost/accumulators/statistics/sum.hpp>

namespace molecool {

    class Timer {

    public:

        Timer(const char* name);
        ~Timer();

        void stop();

    private:

        std::chrono::time_point<std::chrono::steady_clock> m_startTimepoint;
        const char* m_name;
        bool m_stopped = true;

    };

    /////////////////////////////////////////////////////////////////////////

    struct TimerReport {
        TimerReport(const char* /* timer name */, double /* time in us */);
        const char* m_name;
        // accumulator for statistics
        boost::accumulators::accumulator_set<
            double,
            boost::accumulators::stats <
            boost::accumulators::tag::count,
            boost::accumulators::tag::min,
            boost::accumulators::tag::mean,
            boost::accumulators::tag::max,
            boost::accumulators::tag::sum
            >
        > m_acc;

        inline void addData(double t/* time (us) */) { m_acc(t); }
        inline double getMean() { return boost::accumulators::mean(m_acc); }
        inline double getMin() { return boost::accumulators::extract_result< boost::accumulators::tag::min >(m_acc); }
        inline double getMax() { return boost::accumulators::extract_result< boost::accumulators::tag::max >(m_acc); }
        inline size_t getCount() { return boost::accumulators::count(m_acc); }
        inline double getSum() { return boost::accumulators::sum(m_acc); }

    };

    /////////////////////////////////////////////////////////////////////////
    /*
    A singleton class that manages TimerReports generated by individual Timers
    and prints summary data to console when molecool::TimerManager::summary() is called.
    */
    class TimerManager {
        
    public:
        void summary();
        void report(const char* /* timer name */, double /*microseconds*/);

        /*
        static TimerManager& TimerManager::get_instance()
        {
            static TimerManager s;
            return s;
        }
        */

        static std::shared_ptr<TimerManager> getInstance()
        {
            static std::shared_ptr<TimerManager> s{ new TimerManager };
            return s;
        }

        // disable copy/move operations
        TimerManager(TimerManager const&) = delete;
        TimerManager& operator=(TimerManager const&) = delete;

    private:
        TimerManager();
        static std::vector<TimerReport> s_timerReports;
    };

}

